\section{Implementation}
\label{sec:implementation}

We implemented \sys{} in the Firefox and Chrome browsers.
%
The API shown in Figures~\ref{fig:APIspec} and \ref{systemAPI} is specified in 264
lines of WebIDL~\cite{webidl} in Firefox and 70 lines in Chrome.
%
The remaining system is implemented in C++, modifying/extending the Gecko and
Blink layout engines, in roughly 3.4K and 2.6K lines of code (LOC),
respectively.
%
In all our LOC reports, we simply count the length of the source files which
includes comments and empty-lines.
%
Below we detail the implementation of the various \sys{} components;
in Section~\ref{sec:eval}, we present the implementation of the
applications described in Section~\ref{sec:system}.

%\subsection{Policies}
%
Our implementation of the \js|Label|s and \js|Privilege|s is simply a port
of the Haskell implementation presented
in~\cite{stefan:2011:dclabels,stefan:2011:flexible}. 
%
In both Gecko and Blink, these DOM objects are implemented as C++ objects and
mapped to JavaScript objects by binding code, i.e., every property access on
the JavaScript object results in an invocation of a corresponding method on the
Gecko/Blink C++ object via IDL binding code.
%
Our implementation for these objects  is straight forward and only differs in
the two browsers because of their dependence on different container libraries;
the Firefox and Chrome implementations are roughly 1K and 0.7K lines of C++
code, respectively.
%
We note that much of this is a result of using C++ (and thus having
to, for example, implement method overloading to support a friendly
API)---as a comparison a JavaScript implementation of labels is
roughly 100 lines.
%
Below we describe the less-obvious implementation details; we focus on our
Firefox implementation and only describe the Chrome implementation where the
approach diverges in a non-trivial way.
%


Gecko's isolation model relies on \emph{compartments}, i.e., disjoint
JavaScript heaps, for both garbage collection (GC) and
security~\cite{wagner2011compartmental}.
%
The isolation is guaranteed by ensuring that all cross-compartment
communication (e.g., \js|postMessage| between iframes) is done through
\emph{wrappers}---an object from one compartment can never reference
another object from a different compartment directly.
%
This has the benefit that GC can be done in parallel, on different compartments,
and that all inter-browsing context access control checks---as specified, for
instance, by the SOP---can be enforced by the wrappers.
%
Naturally, this is possible because each compartment has a security
principal, i.e., the origin, which is used in making this policy
decision, in addition to those described in
Section~\ref{sec:background} (e.g., SOP, CSP and CORS when using XHR).

Blink differs from Gecko in the way it implements access control checks for
DOM elements. 
%
Specifically, rather than rely on wrappers, Blink implements the SOP security
checks in the binding code for a limited subset of DOM elements that may allow
cross-origin access.
%
This ensures that the performance penalty of wrappers between pages of the same
origin does not exist.
%
Unfortunately, it also requires modifications to the binding code to enforce
confinement for labeled DOM workers (by extending the security checks to all
DOM objects), which imposes a some performance overhead.
\Red{XXX: How much?}

Our implementation relies on compartments and their properties in
several ways.
%
First, we associate label, clearance, and privilege with every 
compartment.
%
Once confinement-mode is enabled, we ``recompute'' all the
cross-compartment wrappers: this ensures that all subsequent
cross-compartment access is mediated by confinement, i.e., it uses
labels, and not the SOP. %, i.e., the principal.
%
We modified the function that recomputes wrappers to use \sys{}'s
wrappers when confinement-mode is enabled.
%
This 81-line patch, in addition to adding a new field (pointing to a \sys{}
object that contains a label, privileges, etc.) to the compartment
object is our most intrusive patch---the other \sys{} components can be
maintained independently.
 
%
In order to enforce confinement, we use the CSP mechanism already present 
in the browser. 
%We use CSP policies, already present in browsers, to enforce
%confinement. 
By doing so, \sys{} does not require specific hooks or extra machinery. 
CSP policies are very expressive; in fact, they are
information flow control policies~\cite{yang:2013:towards}. This allows us
to precisely control how a page loads content, perform XHR, etc.
To enforce CSP, Gecko associates a CSP policy object with a principal.
%We use the compartment principal, and its associated CSP policy to
%restrict network access.
%
We set a custom CSP policy whenever the label is
explicitly set with \js|SWAPI.label|.
%
For example, if the compartment label is
\js|Label("https://bank.ch").and("https://amazon.com")| and privilege
is simply \https{mint.biz}, we set the all the CSP directives to
\js|'none'| (e.g., \js|default-src 'none'|) in addition to the
\js|sandbox| flag that disallows
navigation~\cite{csp1.1,whatwg-html,html5}.
%

When the effective compartment label, i.e., label considering
privileges, is a conjunctive label (or a singleton whose origin is not
the initially set origin), we change the compartment principal to a
fresh, unique (null-) principal. 
%
This ensures that the document is no longer of same origin (as that
at the start of the load) and can thus no longer access the
initially-set-origin's storage.
%
Since these fresh principals always differ, the lifetime of the data does not
span multiple requests.
%
Hence, we additionally set the HTML5 \js|iframe sandbox| flag~\cite{html5},
to revoke access to persistent storage.


When privileges are set (either granted or revoked), the CSP policy is adapted
to reflect that change and allows the corresponding flows of
information. Nevertheless, a compartment that has been associated to a fresh
principal (e.g. when the effective label of a compartment is a conjunction), it
cannot access the storage even when it later gets granted the privilege to do
so. While conservative, we believe this approach is reasonable, e.g.,
it is not clear what it means for a cookie to be labeled with a
conjunction of two principals.

%

Finally, we note that rather than executing labeled workers in a
separate OS-thread, as is the case for existing workers (whose goals
%% To have consistency with other part of the text which use this format
are different from ours), our \js|LWorker| constructor simply creates a new
compartment. This design decision provides 
%
%In addition to 
faster parent-worker calls (e.g.,
\js|postMessage|, or \js|onmessage| dispatch), which are effectively function
calls for which we add confinement checks. 
%
More importantly, it allows \sys{} to provide lightweight workers with access to the
DOM.
%
Specifically, like the new Add-on SDK content-script
extensions~\cite{addon-sdk}, we rely on Gecko's wrappers (which implement the
object-capability \emph{membrane}
pattern~\cite{miller2003paradigm,miller2006robust}) to ensure that each DOM
access abides by confinement (in our case, we conservatively treat each DOM
access, including a \js|get|, from a worker as a read-write effect).
%
In Blink, we extended the IDL binding code to perform label
checks on \emph{all} DOM elements.
%
The added code compares labels of an object's compartment and the compartment
from which the access originates.
%
We must mediate all DOM elements because compartment labels are dynamic, and a
label change may require revocation of DOM access for all DOM objects that the
labeled DOM worker currently processes.



% Local Variables:
% TeX-master: "main.ltx"
% TeX-command-default: "Make"
% End:
