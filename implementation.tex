\section{Implementation}
\label{sec:implementation}

We implemented \sys{} in the Firefox and Chrome browsers.
%
The API shown in Figures~\ref{fig:APIspec} and \ref{systemAPI} is specified in 264
lines of WebIDL~\cite{webidl} in Firefox and 70 lines in Chrome.
%
The remaining system is implemented in C++, modifying/extending the Gecko and
Blink layout engines, in roughly 3.4K and 2.6K lines of code (LOC),
respectively.
%
In all our LOC reports, we simply count the length of the source files which
includes comments and empty-lines.
%
Below we detail the implementation of the various \sys{} components;
in Section~\ref{sec:eval}, we present the implementation of the
applications described in Section~\ref{sec:system}.

%\subsection{Policies}
%
Our implementation of the \js|Label|s and \js|Privilege|s is simply a port
of the Haskell implementation presented
in~\cite{stefan:2011:dclabels,stefan:2011:flexible}. 
%
In both Gecko and Blink, these DOM objects are implemented as C++ objects and
mapped to JavaScript objects by binding code, i.e., every property access on
the JavaScript object results in an invocation of a corresponding method on the
Gecko/Blink C++ object via IDL binding code.
%
Our implementation for these objects  is straight forward and only differs in
the two browsers because of their dependence on different container libraries;
the Firefox and Chrome implementations are roughly 1K and 0.7K lines of C++
code, respectively.
%
We note that much of this is a result of using C++ (and thus having
to, for example, implement method overloading to support a friendly
API)---as a comparison a JavaScript implementation of labels is
roughly 100 lines.
%
Below we describe the less-obvious implementation details; we focus on our
Firefox implementation and only describe the Chrome implementation where the
approach diverges in a non-trivial way.
%


Gecko's isolation model relies on \emph{compartments}, i.e., disjoint
JavaScript heaps, for both garbage collection (GC) and
security~\cite{wagner2011compartmental}.
%
The isolation is guaranteed by ensuring that all cross-compartment
communication (e.g., \js|postMessage| between iframes) is done through
\emph{wrappers}---an object from one compartment can never reference
another object from a different compartment directly.
%
This has the benefit that GC can be done in parallel, on different compartments,
and that all inter-browsing context access control checks---as specified, for
instance, by the SOP---can be enforced by the wrappers.
%
Naturally, this is possible because each compartment has a security
principal, i.e., the origin, which is used in making this policy
decision, in addition to those described in
Section~\ref{sec:background} (e.g., SOP, CSP and CORS when using XHR).

Blink differs from Gecko in the way it implements access control checks for
DOM elements. 
%
Specifically, rather than rely on wrappers, Blink implements the SOP security
checks in the binding code for a limited subset of DOM elements that may allow
cross-origin access.
%
This ensures that the performance penalty of wrappers between pages of the same
origin does not exist.
%
Unfortunately, it also requires modifications to the binding code to enforce
confinement for labeled DOM workers (by extending the security checks to all
DOM objects), which imposes a \Red{XXX} performance overhead, as show in
Section~\ref{sec:eval}.

Our implementation relies on compartments and their properties in
several ways.
%
First, we associate label, clearance, and privilege with every 
compartment.
%
Once confinement-mode is enabled, we ``recompute'' all the
cross-compartment wrappers: this ensures that all subsequent
cross-compartment access is mediated by confinement, i.e., it uses
labels, and not the SOP. %, i.e., the principal.
%
We modified the function that recomputes wrappers to ues \sys{}'s
wrappers when confinement-mode is enabled.
%
This 81-line patch, in addition to adding a new field (pointing to a \sys{}
object that contains a label, privileges, etc.) to the compartment
object is our most intrusive patch---the other \sys{} components can be
maintained independently.
 
%
In order to enforce confinement, we use the CSP mechanism already present 
in the browser. 
%We use CSP policies, already present in browsers, to enforce
%confinement. 
By doing so, \sys{} does not require to add specific hooks or extra machinery. 
CSP policies are very expressive; in fact, they are
information flow control policies~\cite{yang:2013:towards}. This fact allows us
to precisely control how a page loads content, perform XHR, etc.
To enforce CSP, Gecko associates a CSP policy object with a principal.
%We use the compartment principal, and its associated CSP policy to
%restrict network access.
%
We set a custom CSP policy whenever the label is
explicitly set with \js|Browbound.label|.
%
For example, if the compartment label is
\js|Label("https://bank.ch").and("https://amazon.com")| and privilege
is simply \https{mint.biz}, we set the all the CSP directives to
\js|'none'| (e.g., \js|default-src 'none'|) in addition to the
\js|sandbox| flag that disallows
navigation~\cite{csp1.1,whatwg-html,html5}.
%

When the effective compartment label, i.e.., label considering privileges, is
a conjunctive label (or a singleton whose origin is not the initially set), 
we change the compartment principal to a fresh, unique (null-)
principal. 
%
This ensures that the document is no longer of same origin (as that
at the start of the load) and can thus no longer access the
initially-set-origin's storage.
%
Since these fresh principals always differ, the lifetime of the data does not
span multiple requests.
%
Hence, we additionally set the HTML5 \js|iframe sandbox| flag~\cite{html5},
to revoke access to persistent storage.


When privileges are set (either granted or revoked), the CSP policy is adapted
to reflect that change and allows the corresponding flows of
information. Nevertheless, a compartment that has been associated to a fresh
principal (e.g. when the effective label of a compartment is a conjunction), it
cannot access the storage even when it later gets granted the privilege to do
so. While conservative, we believe this approach is reasonable; it is not clear
what it means for a cookie to be labeled with a conjunction of
two principals.

%

Finally, we note that rather than executing labeled workers in a
separate OS-thread, as is the case for existing workers (whose goals
%% To have consistency with other part of the text which use this format
are different from ours), our \js|LWorker| constructor simply creates a new
compartment. This design decision provides 
%
%In addition to 
faster parent-worker calls (e.g.,
\js|postMessage|, or \js|onmessage| dispatch), which are effectively function
calls for which we add confinement checks. 
%
More importantly, it allows us to provide lightweight workers with access to the
DOM.
%
Specifically, like the new Add-on SDK content-script
extensions~\cite{addon-sdk}, we rely on Gecko's wrappers (which implement the
object-capability \emph{membrane}
pattern~\cite{miller2003paradigm,miller2006robust}) to ensure that each DOM
access abides by confinement (in our case, we conservatively treat each DOM
access, including a \js|get|, from a worker as a read-write effect).
%
In Blink, we extended the IDL binding code to perform label
checks on \emph{all} DOM elements.
%
The added code compares labels of an object's compartment and the compartment
from which the access originates.
%
We must mediate all DOM elements because compartment labels are dynamic, and a
label change may require revocation of DOM access for all DOM objects that the
labeled DOM worker currently processes.



% Local Variables:
% TeX-master: "main.ltx"
% TeX-command-default: "Make"
% End:
