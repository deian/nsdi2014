\section{Introduction}
\label{sec:intro}

Web applications have proliferated because of the ease by which
developers can reuse components of existing web applications. While
component reuse in the venerable desktop software model typically takes
the form of libraries, the reusable components in web applications
aren't limited to just JavaScript library code---they include
network-accessible content and services. This reuse is ubiquitous\@:
jQuery, a widely used JavaScript library, is included in and used by
68\% of the Quantcast top-10,000 web sites, and over 52\% of the
Quantcast top-million web sites~\cite{quantcast}. \todo{ds}{update numbers}

When a developer uses these various libraries and services to
build their application, one might wonder: to whom are we entrusting our
private data---our email and bank statements, our health records and
passwords?  Your browser today trusts all of the parties who wrote and
operate the components a service depends on: the developers of jQuery,
the content distribution network that hosts your copy of
jQuery---you even trust the browser extensions that you might have
installed, which run JavaScript written by other parties still.

% expand on this more, by splitting into the restricting (SOP/CSP)
% and the expanding (CORS/etc)
We can reduce the number of trusted parties by enforcing security
policies in the browser. To start with, the Same-Origin Policy (SOP) reduces
the trusted set from the entire Internet to ``merely'' a single origin,
preventing an origin from reading the secrets of another.  Content
Security Policy (CSP) allows even more stringent restrictions.
Sometimes, however, applications want to cross origin boundaries, and
thus Cross-Origin Resource Sharing and HTML5's seamless iframes, iframe
sandbox, and postMessage API~\cite{html5} make it easier to integrate
content from different origins.  But these policies are not enough: the
only way to avoid trusting a service with secret data is to never give
it that data in the first place: but if this service is a password
manager or a personal finance organizer (like {\tt mint.com}), it {\em
needs\/} the sensitive data to implement the functionality of the
application.

% XXX this isn't right, write down what I really want to say
The step to nirvana is shockingly small.  First, we must take SOP and
CSP and extend their capabilities to enable security policies which
enforce true {\em confinement\/} of untrusted code, where sensitive data
cannot be exfiltrated from the browsing context.  Second, applications
must be able to ensure that any entity they pass sensitive data to
respects (and will continue to respect) an acceptable security policy.
Finally, it must be possible to raise an entity's security policy to an
acceptable level when it receives sensitive data.  In effect, with one new
CSP policy directive, a method for checking if a CSP policy is
acceptable, and a method for dynamically changing CSP policy, it
suddenly is possible to safely pass sensitive data to untrusted
JavaScript.  Of course, the precise details of how to decide if
a policy is sufficient and want changes to policy are permissible
are tricky, but this design is well-motivated by decades of foundational
work in \emph{information flow control}.

%   This enforcement must be \emph{transitive}---if we confine a library,
%   then any sub-libraries it uses should also be confined---and
%   \emph{symmetric}---if I give you a secret and you give me a secret, we
%   should both be held to each other's security policies.

In this paper, we present \sys{} (the Secure Web API), a simple
mandatory access control (MAC) system for web browsers that delivers
both flexibility for web application developers and robust privacy for
users. \sys{} allows untrusted JavaScript to process sensitive data.  We
validate our design with five case-study applications---a password
strength-checker, a password manager, a banking application that uses
the (untrusted) jQuery library, a ``phone numbers-to-links'' browser
extension, and a third-party mashup, none of which can be implemented in
a way that ensures privacy in today's web browsers.  Our contributions are as
follows:

\begin{CompactItemize}
\item While information flow control is by no means a new concept for
    enforcing security and the core elements of our design have been
    seen previously in the literature, we demonstrate how close existing
    browser security mechanisms are to achieving our security goals, and
    describe what incremental steps must be made to enable floating label-based
    information flow control in web applications.
\item We propose a browser API for mandatory-access control which is practical
    and closely modeled off of existing browser APIs such as Web Workers.
\item We implement our system and evaluate the performance overhead
    in Firefox and Chromium open-source browsers, demonstrating that
    SWAPI incurs minimal performance overhead (unlike many previous
    IFC systems for browsers).
\item We validate our design by implementing five-case study applications
    on top of SWAPI\@.
\end{CompactItemize}


% Local Variables:
% TeX-master: "main.ltx"
% TeX-command-default: "Make"
% End:
