## High-level questions

B, D: What kinds of applications is COWL not sufficient for?

    Underlying the design of COWL is the assumption that applications
    need not mix data of different sensitivity in the same compartment
    and continue communicating. Note, however, that because COWL
    supports arbitrary nesting of compartments, one may introduce
    nesting to "force" data of different sensitivity into distinct
    compartments. If one is "porting" a legacy application to COWL,
    this may be inconvenient for the programmer.  Moreover, since
    inter-compartment communication in asynchronous, one might give up
    the intuitive ease of synchrony within a single compartment when
    compartmentalizing.

    However, applications that require policies that do not fit within
    the lattice/label model may not be expressible. (See below.)

B, D, E: What does COWL give up by taking a coarse-grained approach?

  We touch on some of the trade-offs of coarse-grained vs.
  fine-grained IFC in the related work section, but agree that this
  discussion was directed at individual prior systems rather than
  drawing conclusions about these two broad approaches.
  Coarse-grained (compartment-granularity) IFC is much
  easier to implement than fine-grained (object-granularity) IFC;
  the former requires no changes to the JavaScript
  execution engine, whereas the latter requires extensive changes to
  propagate and check labels for every low-level JavaScript
  operation. The coarse-grained approach also incurs far less
  execution overhead: label-related processing occurs nearly
  exclusively upon inter-compartment communication, rather than at
  every step of a computation, in every compartment.

  We conjecture (but have not yet proven) that coarse-grained and
  fine-grained IFC are equally expressive, provided one can
  introduce arbitrary nesting of compartments.  Even if this
  equivalence holds in theory, in practice, it's unattractive for
  the programmer to need to introduce deep nesting of compartments
  to emulate fine-grained IFC (and presumably slower than
  fine-grained IFC, if you literally put compartments around every
  individual object).

  Fine-grained IFC can require less programmer effort in some cases.
  For example (as we briefly mention in the related work discussion
  of JSFlow), when trying to confine an untrusted jQuery library in
  the same page as the trusted application code and sensitive data,
  COWL requires the programmer to explicitly partition the page into
  a trusted and untrusted compartment. (This is somewhat reminiscent
  of least-privilege partitioning, in the style of OKWS and Wedge.)
  However, the fine-grained approach lets jQuery remain in the same
  compartment as the trusted code and sensitive data.

D: How general is the label system?

  As described in Section 3.1, we use the logic-based DCLabels of
  [28]. The particular logic is propositional logic without negation.
  More expressive logics (e.g., first order logic) can allow for
  richer policies than those permitted by DCLabels. For instance, even
  allowing negation would permit more expressive policies such as
  "this labeled blob cannot be read by a.com." With DCLabels, such
  policies must be encoded by "white-listing" all the permitted
  readers except a.com. We chose DCLabels because they correspond
  closely to the existing web policies, and we thus believe that web
  developers will find them intuitive.

B: The tainted component does not need communication after initially
obtaining its taint/private information. Is that what's required of
applications in order for them to be secured by COWL?

    Yes: this is the defining characteristic of floating label dynamic
    information flow control systems.  However, as described in Section
    3.2, privileges are an escape-valve which allow *trusted* code to
    declassify sensitive information for communication; untrusted code
    has no recourse, and rightly so!

A: Will mashups with many libraries impose a requirement on developers to understand overly-complex policies?

    We acknowledge that programming with COWL definitely does require
    understanding COWL's primitives. However, our experience to date
    (as illustrated in the four example applications) is that a
    relatively small set of canonical design patterns captures many of
    the common web application (and mashup) behaviors. We believe that
    a higher-level policy language could let developers express
    intricate policies (e.g., that involve many libraries and mutual
    distrust among them) in a straightforward way, and that a compiler
    could then compile such policies into the COWL primitives. Such a
    language and compiler are the subject of our future work.

## Factual questions

B, D, E: What about integrity?

    Each label contains an integrity component; the design of
    integrity is complete and implemented, but was given short shrift
    in the submission for reasons of brevity.  As suggested, we intend
    to expand on this.

E: SOP "provides some degree of integrity" for DOM changes, what about COWL?

    In Section 3.2, we mention that a privilege is required to modify
    the DOM.  Privileges are allocated in the same manner as traditional SOP,
    so the integrity guarantees are the same.

E: Is your vision to co-exist or replace all existing security mechanisms?

    COWL is explicitly designed to allow for an incremental deployment
    path.  While prior work (e.g., [40]) discusses how a label system
    can subsume the policies that can be implemented with today's SOP,
    CSP, CORS, etc, COWL co-exists with these mechanisms, offering MAC
    to pages which opt-in to this new functionality (summarized in
    Section 3).

E: How do you address taint-accumulation for compartments and files?

    First, compartments: Accumulation of labels has been described in the
    context of previously proposed taint-tracking systems. Two design
    features of COWL make such label accumulation less problematic for
    COWL's compartments. First, COWL allows one to create compartments. If
    a developer knows that a script needs to process sensitive data (i.e.,
    raise its label), she can always elect to run that script in a
    separate compartment (and thus confine the additional label to that
    compartment). Second, COWL's support for labeled blobs allows a script
    to receive messages of distinct sensitivity classes, *not* read their
    payload, but inspect their labels. By doing so, a developer can then
    intelligently decide when spawning a distinct compartment before
    reading a payload is desirable (so as to avoid accumulating too much
    taint). In addition, a compartment's lifetime spans only the period
    during that a user remains on a page; all labels vanish when the user
    navigates away from a page.

    Second, files: we do not believe that accumulation of many labels is
    fundamental to local storage. While we have not yet codified a
    complete design for local storage or implemented it, we envision that
    under COWL, while a compartment raises its label before reading
    sensitive data, a file would *not* simply raise its label for each
    sensitivity class of data written to it. Instead, the labels on files
    would be immutable (as in prior coarse-grained IFC systems, such as
    HiStar [42] and Hails/LIO [11]); as shown in a recent CSF paper,
    flow-insensitive systems (i.e., systems that consider object labels to
    be immutable) can be used to encode flow-sensitive objects (i.e.,
    objects whose labels change according to the sensitivity of data being
    written to them).

A: What kind of objects can be labeled?

    Blobs, which can include serialized JavaScript values (e.g.
    as seen in postMessage).

A, B: How do you disallow the manual setting of label XHR header?

    The XHR API has the option for users to add custom headers to the
    request, as long as they are not a reserved header.  Label headers
    are also considered reserved, disallowing their "manual" modification.

B: What is the covert channel story for COWL?

    As mentioned in Section 3, COWL both restricts and relaxes the SOP.
    When the SOP is restricted--i.e., no labeled XHR was used--the
    question of covert channels is irrelevant,  since webpages do not
    have direct access to any more sensitive data than they would have
    had access to already.  This is the case for 3/4 example applications.

    Labeled XHR allows access to sensitive data that would not be
    accessible under SOP, so covert channels are a definite concern
    here.  In Section 3.3, we discuss how clearance can be used to
    restrict the sensitivity of data that can be read (and thus leaked
    via covert channels), allowing access only to data a compartment
    "needs to know." As also mentioned, to achieve the functionality of
    third-party mashup sites, the status quo requires the user to give
    up their password; COWL significantly improves this state of
    affairs.

B: Does the sharing of heap space for LWorker introduce new covert channels?

    Our implementation of LWorkers repurposes V8 and SpiderMonkey's
    contexts and compartments, respectively. These primitives are already
    used to isolate iframes of different origins to ensure that they
    operate on disjoint sub-heaps. Hence, we believe the chance of
    unauthorized leakage of information between LWorkers is identical to
    that between iframes.

A: What the label check done when accessing DOM of compartment?

    Each compartment has distinct secrecy and integrity labels (though
    the submission elides many of the details of integrity labels in
    the interest of brevity). Suppose compartment A tries to modify
    the DOM of compartment B. The label check is as follows: the
    operation is allowed if compartment A's integrity label implies
    compartment B's (the reverse implication to the label check for
    secrecy, as we stated somewhat opaquely in footnote 8). If this
    label check fails (as it would if compartment Bâ€™s label were
    "public," as is typically the case), the operation is *still*
    allowed if compartment A holds the privilege for the origin of
    compartment B. In other words, "exercised" here signifies an
    "override" of the integrity label check to allow a
    cross-compartment DOM write when the writing compartment holds the
    privilege for the origin of the written compartment. (Privilege
    analogously affects secrecy label checks, as described in the
    first two bullets in Section 3.2.)

D: What did you mean by ambient authority?

    Under the SOP, the notion of origin is always implicit: a page is
    loaded from a URL, and that compartment is forever associated with
    that exact origin. By "ambient authority" we mean the origin is
    implicit in the page. By contrast, under COWL, a compartment has
    explicit control over its label (and privilege).

C: Why is the iframe and worker creation in Firefox faster for the labeled case?

    We believe this difference (14.5 ms unlabeled, 14.4 ms labeled) is
    small enough to be explained by variability in the distribution of
    completion times.


C: Why do you exchaust the call stack and is this limit set by the spec?

    The number of stack frames depends on the underlying JavaScript
    engine implementation (not the spec). The Firefox implementation
    exhausted the call stack at 90 messages, since the LWorkers run in
    the same context as the parent, so a message exchange is a
    function call.

C: Why did you use a "simplified version" of the encrypted document editor?

    The "simplified version" was the baseline for comparison (i.e.,
    running in today's Firefox browser, without COWL). It wasn't clear
    how to implement this application with the same privacy guarantees
    in the baseline browser, so we implemented a version without any
    privacy guarantees. As we would expect a version with any sort of
    partial privacy to run more slowly (because of added cryptographic
    operations), the "simplified version" if anything overstates the
    performance penalty of the COWL version of the application.

D:  Why is CSP too restrictive for the password checker example when it can be used to white-list origins?

    It's correct that one could use CSP in a way that would allow the
    password checker to communicate with an origin that hosts updated
    regular expressions for weak passwords. However, CSP is a
    discretionary access control mechanism: once you grant access to
    communicate with an origin, that access persists for that
    page. Thus, using CSP to specify that the password checker may
    communicate with a remote origin would allow the checker to send
    the user's passwords to that remote origin.

## PRESENTATION 

We will take the reviewers' comments on presentation into
consideration and revise the writing to address them (e.g., C's
comments on showing code for the checker, and explaining CSP in the
style of the background, etc.).

D: Underlines, colors, bubbles?

    We unfortunately neglected to state in our submission that 
    underlined origin indicates that a compartment holds the privilege for
    that origin. We colored different origins differently for
    contrast. In these examples, all spiked bubbles connote the
    raising of labels.
